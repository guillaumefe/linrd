import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
//import { loadYaml } from './pipelinrLoadYaml';
import { useDispatch } from 'react-redux';

import { loadYaml } from '../services/Load';

const initialState = {
    tasks: [],
    value: "",
    searchterm: "",
    status: "",
    error: "",
};

//export const saveAsync = createAsyncThunk(
//  'pipelinr/save',
//  async (value) => {
//    const response = await save(value);
//    // The value we return becomes the `fulfilled` action payload
//    return response.data;
//  }
//);

export const transformAsync = createAsyncThunk(
  'pipelinr/transform',
  async (value) => {
      //const response = await 
      loadYaml(value).then(function(tasks) {
          return tasks
      });
      //dispatch(uploadTasks(response))
      //return response
  }
);

export const pipelinrSlice = createSlice({
  name: 'pipelinr',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        update: (state, action) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the Immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            state.value = action.payload;
        },
        updateTasks: (state, action) => {
            state.tasks = action.payload;
            //state.tasks.sort( (a,b) => (parseInt(a.duration) || 0) - (parseInt(b.duration) || 0) )
            //state.tasks.sort( (a,b) => (Date.parse(a.deadline) || new Date() ) - (Date.parse(b.deadline) || new Date()) )
        },
        updateSearchTerm: (state, action) => {
            state.searchterm = action.payload;
        },
	sortTasks : (state) => {
            state.tasks.sort( (a,b) => (parseInt(a.duration) || 0) - (parseInt(b.duration) || 0) )
            state.tasks.sort( (a,b) => (Date.parse(a.deadline) || new Date() ) - (Date.parse(b.deadline) || new Date()) )
	},
        updateTask: (state, action) => {
            //let result = state.tasks.map( task => (task.key.join() === action.payload.key.join()) ? action.payload : task)
            //state.tasks = result;
            //let count = 1
            //const result = state.value.split('\n').map( line => {
            //    if (count === action.payload.line){
            //        switch (action.payload.action) {
            //            case "done":
            //                return line + " --"
            //        }
            //    } else {
            //        return line
            //    }
            //    count++
            //})
            //const value = result.join("\n")
            //state.value = value
        },
        displayError: (state, action) => {
            state.error = action.payload;
        },
  },
  //// The `extraReducers` field lets the slice handle actions defined elsewhere,
  //// including actions generated by createAsyncThunk or in other slices.
  //extraReducers: (builder) => {
  //  builder
  //    .addCase(saveAsync.pending, (state) => {
  //      state.status = 'saving';
  //    })
  //    .addCase(saveAsync.fulfilled, (state) => {
  //      state.status = 'saved';
  //    });
  //},
});

export const { update, updateTasks, updateSearchTerm, displayError, sortTasks } = pipelinrSlice.actions;

export const selectValue = (state) => state.pipelinr.value;
export const selectSearchTerm = (state) => state.pipelinr.searchterm;
export const selectTasks = (state) => state.pipelinr.tasks;
export const selectError = (state) => state.pipelinr.error.toString();

export default pipelinrSlice.reducer;
